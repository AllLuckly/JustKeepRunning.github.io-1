---
layout: post
title: 去model化尝试
categories: iOS-Dev
description: 去model化是一种框架设计上的做法，其中的model并不是指架构中的model层，套用Casa大神博客中的原文就是：model化就是使用数据对象，去model化就是不使用数据对象。
---

`去model化`是一种框架设计上的做法，其中的`model`并不是指架构中的`model`层，套用Casa大神博客中的原文就是：

> model化就是使用数据对象，去model化就是不使用数据对象。

常见的`去model化`做法是使用字典保存数据信息，然后提供一个`reformer`负责将这些字典数据转换成`View`层可展示的信息，其流程图如下：
<span><img src="/images/去model化尝试/1.jpeg" width="800"></span>
更详细的理论知识可以看Casa大神的[去model化和数据对象](http://casatwy.com/OOP_nomodel.html)。本文基于Casa大神的实践基础使用另外一种`去model化`的实现方式。

##使用背景
在很早之前就看过大神的文章，不过一直没有去尝试这种做法。在笔者最近跳入新坑之后，总算是有了这么一次机会。需求是存在着三个非常相似的`cell`，但分别对应着不同的数据`model`：
<span><img src="/images/去model化尝试/2.jpeg" width="800"></span>
总结三个`cell`都需要的展示数据包括：
- 产品名称
- 使用条件
- 截止日期
- 背景图片

此外，`优惠信息`属于第一个和第二个独有的。可以看到三个`cell`非常的相似，完全封装成同一个视图。但由于每一种单元格对应着自己的数据对象，这大大减少了封装的可能性。因此，笔者采用了去`property`改用`protocol`统一数据模型的做法来实现视图的统一封装

##实现
为了让`cell`可以不受到`model`的限制来正常显示内容，我分别制定了针对它们两个的协议，关系图如下：
<span><img src="/images/去model化尝试/3.jpeg" width="800"></span>
正常开发中，我们的单元格过多的受限于数据对象的具体类型，两者之间存在过大的耦合。这意味着如果服务器返回的数据字段一旦发生改变，我们的`model`跟`view`也要进行修改来避免发生可预见的`crash`。上图的架构实现方式解决了这个问题，通过其中一个`model`的代码来看看具体的实现思路 （在上图的`ModelProtocol`中笔者少写了一个`-initWithDict:`接口方法）：

    // h文件
    @interface LXDCouponTicketModel: NSObject<LXDTicketModelProtocol>

    @end

    // m实现
    @implementation LXDCouponTicketModel
    {
        NSDictionary * _dict;
    }

    - (NSString *)backgroundImageName
    {
        return ([_dict[@"overdue"] boolValue] ? @"coupon_overdue" : @"coupon_common");
    }

    - (NSAttributedString *)perferential
    {
        NSAttributedString * result = objc_getAssociatedObject(self, KMCPerferentialKey);
        if (result) { return result; }
    
        NSMutableAttributedString * attributedString = [[NSMutableAttributedString alloc] initWithString: @"￥" attributes: @{ NSFontAttributeName: [UIFont systemFontOfSize: 16] }];
        [attributedString appendAttributedString: [[NSAttributedString alloc] initWithString: [NSString stringWithFormat: @"%g", [_dict[@"ticketMoney"] doubleValue]] attributes: @{ NSFontAttributeName: [UIFont boldSystemFontOfSize: 32] }]];
        [attributedString addAttributes: @{ NSForegroundColorAttributeName: KMCCommonColor } range: NSMakeRange(0, attributedString.length)];
        result = attributedString.copy;
        objc_setAssociatedObject(self, KMCPerferentialKey, result, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        return result;
    }

    - (NSString *)goodName
    {
        return [_dict[@"goodName"] stringValue];
    }

    - (NSString *)effectCondition
    {
        return [NSString stringWithFormat: @"· 满%lu元可用", [_dict[@"minLimitMoney"] unsignedIntegerValue]];;
    }

    - (NSString *)deadline
    {
        return [NSString stringWithFormat: @"· 兑换截止日期：%@", _dict[@"deadline"]];
    }

    - (LXDCellType)type
    {
        return LXDCellTypeCoupon;
    }

    - (instancetype)initWithDict: (NSDictionary *)dict
    {
        if (self = [super init]) {
            _dict = dict;
        }
        return self;
    }
首先在协议中的每一个属性笔者都声明为`readonly`修饰，保证只需实现`getter`且将所有的`数据->展示`这一过程中的业务逻辑放在`model`中。`model`本身不包含任何成员属性，只持有一份服务器返回的字典数据对象。通过统一`model`的属性返回，在`cell`中的展示代码如下：

    // h文件
    @interface LXDTicketCell: UITableViewCell<LXDTicketCellProtocol>

    @end

    // m实现
    #define LXDCommonColor [UIColor colorWithRed: 253/255. green: 99/255. blue: 99/255. alpha: 1]

    @implementation LXDTicketCell

    - (void)configurateWithModel: (id<LXDTicketModelProtocol>)model
    {
        UIView * goodInfoView = _goodNameLabel.superview;
        if ([model type] != KMCTicketTypeConvert) {
            [goodInfoView mas_updateConstraints: ^(MASConstraintMaker *make) {
                make.left.equalTo(_perferentialLabel.mas_right).offset(10); }];
        } else {
            [goodInfoView mas_updateConstraints: ^(MASConstraintMaker *make) {
                make.left.equalTo(_backgroundImageView.mas_left).offset(18); }];
        }
        
        [_use setTitleColor: LXDCommonColor forState: UIControlStateNormal];
        _backgroundImageView.image = [UIImage imageNamed: [model backgroundImageName]];
        _perferentialLabel.attributedText = [model perferential];
        _effectConditionLabel.text = [model effectCondition];
        _goodNameLabel.text = [model goodName];
        _deadlineLabel.text = [model deadline];

        [_effectConditionLabel sizeToFit];
        [_goodNameLabel sizeToFit];
        [_deadlineLabel sizeToFit];
    }

    @end
首先声明的`ModelProtocol`中抽离出数据对象在`cell`上的展示属性，然后通过`cell`实现协议方法来传入一个遵循`ModelProtocol`的对象，调用`getter`方法来获取自己需要展示的信息展示。在这期间，`cell`不在乎传入的对象的具体类型，解除`View<->Model`之间存在的耦合关系。这一种实现方式的好处还不仅在于这里，同样控制器层的代码也可以变得简单：

    // m实现
    @interface LXDTicketViewController ()

    @property (nonatomic, strong) NSMutableArray< id<LXDTicketModelProtocol> > * couponTickets;
    @property (nonatomic, strong) NSMutableArray< id<LXDTicketModelProtocol> > * discountTickets;
    @property (nonatomic, strong) NSMutableArray< id<LXDTicketModelProtocol> > * convertTickets;    

    @end

    @implementation LXDTicketViewController

    #pragma mark - UITableViewDataSource
    - (UITableViewCell *)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath
    {
        UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier: KMCTicketCommonCellIdentifier];
        if ([cell conformsToProtocol: @protocol(LXDTicketCellProtocol)]) {
            [(id<LXDTicketCellProtocol>)cell configurateCellWithModel: [self modelWithIndexPath: indexPath]];
        }
        return cell;
    }

    #pragma mark - Data Generator
    - (id<LXDTicketModelProtocol>)modelWithIndexPath: (NSIndexPath *)indexPath
    {
        return self.currentModelSet[indexPath.row];
    }

    - (NSMutableArray< id<LXDTicketModelProtocol> > *)currentModelSet
    {
        switch (_ticketType) {
            case KMCTicketTypeCoupon:
                return _couponTickets;
            
            case KMCTicketTypeDiscount:
                return _discountTickets;
            
            case KMCTicketTypeConvert:
                return _convertTickets;
        }
    }

    @end
由于我们声明了包括`model`和`cell`的协议，这时候对于控制器来说，这两者的具体类型已经无关紧要了，控制器所要完成的工作就是将实现了`ModelProtocol`的数据对象传递给同样实现了`CellProtocol`的单元格视图即可。当然，控制器只是创建了几个相似的容器，但是归根到底，从服务器返回`json`数据到转换成对应的`model`的这个业务工作还是要有某个对象来实现，笔者在这里引入了中间类`Helper`来完成这些`model`的创建工作：

    // h文件
    @interface LXDTicketDataHelper: NSObject

    + (void)anaylseJSON: (NSString *)JSON complete: (void(^)(NSMutableArray< id<LXDTicketModelProtocol> > *)models); 

    @end

    // m实现
    #import "LXDCouponTicketModel.h"
    #import "LXDConvertTicketModel.h"
    #import "LXDDiscountTicketModel.h"

    @implementation LXDTicketDataHelper

    + (void)anaylseJSON: (NSString *)JSON complete: (void(^)(NSMutableArray< id<LXDTicketModelProtocol> > *)models)
    {
        NSParameterAssert(JSON);
        NSParameterAssert(complete);

        [LXDQueue executeInGlobalQueue: ^{
            Class ModelCls = NULL;
            NSDictionary * jsonDict = [NSDictionary dictionaryWithJSON: JSON];
            NSMutableArray< id<LXDTicketModelProtocol> > * results = @[].mutableCopy;

            // 使用switch简单工厂，如果case太多时，使用继承关系的工厂会更好
            switch ((LXDModelType)[jsonDict[@"modelType"] integerValue]) {
                case LXDModelTypeCoupon:
                ModelCls = [KXDCouponTicketModel class];
                break;

                case LXDModelTypeConvert:
                ModelCls = [LXDConvertTicketModel class];
                break;

                case LXDModelTypeDiscount:
                ModelCls = [LXDDiscountTicketModel class];
                break;
            }
        
            for (NSDictionary * dataDict in jsonDict[@"data"]) {
                id item = [(id<LXDTicketModelProtocol>)[ModelCls alloc] initWithDict: dataDict];
                [result addObject: item];
            }
            [LXDQueue executeInMainQueue: ^{
                complete(result);
            }];
        }];
    } 

    @end

    // m实现
    #import "KMCNetworkHelper.h"    

    @implementation LXDTicketViewController

    - (void)requestTickets
    {
        // get request parameters include 'url' and 'parameters'
        [LXDNetworkManager POST: PATH(url) parameters: parameters 
              complete: ^(NSString * JSON, NSError * error) {
            // error check
            [LXDTicketDataHelper analyseJSON: JSON complete: ^(NSMutableArray * models) {
                [self.currentModelSet addObjectsFromArray: models];
            }];
        }];
    }

    @end
`去model化`之后整个项目的业务流程大致可以用下图表示：
<span><img src="/images/去model化尝试/4.jpeg" width="800"></span>
这种方式最大的好处在于控制器和视图不再依赖于`model`的具体类型，这样在服务器返回的`json`中修改了模型对象字段的时候，修改`ModelProtocol`的对应实现即可。甚至在以后的版本再添加`现金券`各种其他票券的时候，只需要在`Helper`这一环节添加相应的工厂即可完成改动

##尾言
`去model化`是一种有效快捷的松耦合方式，但绝不是`万能药`。在本文的demo中不难看到笔者使用这一方式最大的原因在于多个`cell`之间有太多的共性而`model`的属性字段全不相同。另一方面在这种设计中`Helper`可能会因为模型对象的增加变得臃肿，需要谨慎使用。
一个好的项目框架总是随着需求改变在不断的调整的，没有绝对最佳的设计方案。但是尝试使用不同的思路去搭建项目可以提升我们的认知，培养对于开发框架设计的认识。

转载请注明本文地址及作者

